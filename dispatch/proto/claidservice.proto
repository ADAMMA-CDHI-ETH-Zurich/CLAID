syntax = "proto3";

package claidservice;

option go_package = "claid.ethz.ch/claidservice";

option java_package = "adamma.c4dhi.claid";
option java_outer_classname = "ClaidJavaService";
option java_multiple_files = true;


import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";


// Service for modules to talk to the CLAID middleware.
service ClaidService {
  // Continuous stream of DataPackage's between client and server.
  rpc SendReceivePackages(stream DataPackage) returns (stream DataPackage) {}

  // Get the modules to set up during initialization.
  rpc GetModuleList(ModuleListRequest) returns (ModuleListResponse) {}

  // Init Modules
  rpc InitRuntime(InitRuntimeRequest) returns (google.protobuf.Empty) {}
}

// Service for two instances of the CLAID middleware to talk to each other over a TCP connection.
service ClaidRemoteService
{
  // Continuous stream of DataPackage's between remote client and remote server.
  rpc SendReceivePackages(stream DataPackage) returns (stream DataPackage) {}

  // Registers the client (identified by user_token and device_id) with the server.
  // rpc RegisterRemoteClient(RemoteClientInitRequest) returns (google.protobuf.Empty) {}
}

message DataPackage {
  string id = 1;      // Unique ID of this package
  string channel = 2;
  string source_module = 3; // originating module id
  string target_module = 4; // target module id
  string source_host = 5; // originating host name
  string target_host = 6; // target host name
  string source_user_token = 7;  // id token of the user / system entity that created this package.
  string target_user_token = 8; // id of the user / system that this package is intended for, if it is intended to send data to a module of a specific user.
                                // typically, this will be *, meaning that the package will be forwarded to all users that run the corresponding host.
  string device_id = 9;    // unique ID for this device / host, e.g. MAC id
  repeated TracePoint trace_points = 10;
  uint64 unix_timestamp_ms = 11; // unix timestamp in milliseconds of when the package was created

  // To add another message type add it below.
  oneof payload_oneof {
    ControlPackage control_val = 30;
    double number_val = 31;
    string string_val = 32;
    bool bool_val = 33;
    NumberArray number_array_val = 34;
    StringArray string_array_val = 35;
    NumberMap number_map = 36;
    StringMap string_map = 37;
    Blob blob_val = 38;
  }
}

enum CtrlType {
  CTRL_UNSPECIFIED      = 0;
  CTRL_RUNTIME_PING     = 1;  // Client sends this upon connect and periodically if no packages have been sent
  CTRL_REMOTE_PING      = 2;  // RemoteClient sends this upon connect to a RemoteDispatcherServer upon connect.
  CTRL_REMOTE_PING_PONG = 3;  // Response to a CTRL_REMOTE_PING.
  CTRL_CONN_CANCEL      = 4;  // Signal by the client that it is about to cancel the request.
  // CTRL_MODULE_READY  = 5;  // sent to module when the local middleware is ready
  // CTRL_STATUS        = 6;  // Sent from a middleware client up the tree
  // CTRL_ACTION        = 7;  // sent to module when the local middleware is ready
  CTRL_ERROR            = 8;  // Error occured
  CTRL_CONNECTED_TO_REMOTE_SERVER       = 9; // If RemoteDispatcherClient connected to a Server
  CTRL_DISCONNECTED_FROM_REMOTE_SERVER  = 10;
  CTRL_UNLOAD_MODULES                   = 11;
  CTRL_UNLOAD_MODULES_DONE              = 12;
  CTRL_RESTART_RUNTIME                  = 13;
  CTRL_RESTART_RUNTIME_DONE             = 14;
  CTRL_REQUEST_MODULE_ANNOTATIONS       = 15;
  CTRL_REQUEST_MODULE_ANNOTATIONS_RESPONSE  = 16;
  CTRL_UPLOAD_CONFIG_AND_DATA               = 17; // Will be received by the middleware (not forwarded to the Runtimes). Can be used to load a new config into a host alongside with additional data (model files, python code to inject etc.). Requires designer_mode in CLAIDConfig to be true.
  CTRL_ON_NEW_CONFIG_PAYLOAD_DATA           = 18; // Will be sent by the middleware to all local Runtimes after the Middleware received a package of type CTRL_UPLOAD_CONFIG_AND_DATA. Informs the Runtimes that new payloads are available.
  //CTRL_ADD_MODULE                         = 11; // Can be used to add a new Module at runtime (requires Module name, properties, channels). This package will be forwarded by the LocalRouter to the Middleware that can handle this Module.
  //CTRL_REMOVE_MODULE                      = 12; // Can be used to remove a Module at runtime.
  //CTRL_ADD_MODULE_SUCCESS                 = 13; // Sent as response to CTRL_ADD_MODULE the Module was added successfully.
  //CTRL_REMOVE_MODULE_SUCCESS              = 14; // Sent as response to CTRL_REMOVE_MODULE the Module was removed successfully.
  //CTRL_ADD_MODULE_FAILURE                           = 15; // Sent as response to CTRL_ADD_MODULE the Module could not be added.
  //CTRL_REMOVE_MODULE_FAILURE                        = 16; // Sent as response to CTRL_REMOVE_MODULE the Module could not be removed.
  //CTRL_PAUSE_ALL_RUNTIMES                           = 17; // Can be used to pause all runtimes (the ModuleManager of each Runtme will pause the RunnableDispatcher of all its Modules).
  //CTRL_UNPAUSE_ALL_RUNTIMES                         = 18; // Can be used to unpause all runtimes (the ModuleManager of each Runtime will unpause the RunnableDispatcher of all its Modules).

}

// Note for Stephan: I removed the "optional" labels, as protoc did complain about them:
// "Explicit 'optional' labels are disallowed in the Proto3 syntax. To define 'optional' fields in Proto3, simply remove the 'optional' label, as fields are 'optional' by default.

message ControlPackage {
  CtrlType ctrl_type                        = 1;
  Runtime runtime                           = 2; // CTRL_RUNTIME_PING, CTRL_ADD_MODULE, CTRL_REMOVE_MODULE, CTRL_ADD_MODULE_SUCCESS, CTRL_REMOVE_MODULE_SUCCESS
  RemoteClientInfo remote_client_info       = 3; // CTRL_REMOTE_PING
  AccumulatedStatus status                  = 4; // CTRL_STATUS: status sent towards root server
  ErrorMsg error_msg                        = 5; // CTRL_ERROR: Error report sent towards root server
  ActionRequest action_request              = 6; // CTRL_ACTION: action request sent to all children of the claid instance
  map<string, ModuleAnnotation> module_annotations = 7; // CTRL_REQUEST_MODULE_ANNOTATIONS_RESPONSE
  ConfigUploadPayload config_upload_payload        = 8; // CTRL_UPLOAD_CONFIG_AND_DATA and CTRL_ON_NEW_CONFIG_PAYLOAD_DATA;
}

message AccumulatedStatus {
  // TBD
}

message ErrorMsg {
  string message = 1;
  bool cancel = 2;
}

// enum ErrorLevel {
//   ERR_LEVEL_UNSPECIFIED = 0;
//   ERR_LEVEL_WARNING = 1;
//   ERR_LEVEL_FATAL = 2;
// }

message ActionRequest {
  // TBD
  map<string, string> action_params = 1;
}

message NumberArray {
  repeated double val = 1;
}

message StringArray {
  repeated string val = 1;
}

message NumberMap {
  map<string, double> val = 1;
}

message StringMap {
  map<string, string> val = 1;
}

message Blob {
  Codec codec = 1;

  // The byte blob containing the payload data.
  bytes payload = 2;

  string name = 3;  // local name of the blob (e.g. file name)

  // type and subtype contains meta information to decode the bytes contained above.
  // See this list of common mime types
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  //
  string message_type = 4;  // mime type, protobuf type (to decode payload)
  string sub_type = 5;      // mime subtype, etc.
}

enum Codec {
  CODEC_UNSPECIFIED = 0;
  CODEC_BYTES       = 1;   // Just a bytes blob (no-op codec)
  CODEC_FILE        = 2;    // File blob
  CODEC_JSON        = 3;    // JSON data (maybe decode)
  CODEC_PROTO       = 4;   // Decode based on registry
}

message TracePoint {
 google.protobuf.Timestamp time_stamp = 1;
 string node_id = 2;  // full module id:  host_id:module_type
}

// Sent by the client (Runtime) to tell the Middleware which Modules it supports.
// The Middleware will answer with a ModuleListResponse, which contains the Modules
// that the Middleware wants the runtime client to load.
message ModuleListRequest {
  Runtime runtime = 1;
  repeated string supported_module_classes = 2;
  map<string, ModuleAnnotation> module_annotations = 3;
}



// List of modules that the runtime client is expected to instantiate.
message ModuleListResponse {
  message ModuleDescriptor {
    string module_id = 1;
    string module_class = 2;
    map<string, string> properties = 3;
    // repeated DataPackage channels = 4;
  }

  repeated ModuleDescriptor descriptors = 1;
}

// Sent by the client after the modules have been instantiated
// to inform the server what channels will be sent.
message InitRuntimeRequest {
  message ModuleChannels {
    string module_id = 1;
    repeated DataPackage channel_packets = 2; // channel, source | target, payload => define the channel
  }

  Runtime runtime = 1;
  repeated ModuleChannels modules = 2;
}

message RemoteClientInfo
{
  string host = 1;
  string user_token = 2;
  string device_id = 3;
}

// Used by CTRL_ADD_MODULE to add a Module at Runtime.
// Requires a full definition of the Module: Name, class, properties, channels
message AddModuleRequest 
{
  string module_id = 1;
  string module_class = 2;
  map<string, string> properties = 3;
  repeated DataPackage channel_packets = 4;
}

// Used by CTRL_REMOVE_MODULE to remove a Module at Runtime.
message RemoveModuleRequest
{
  string module_id = 1;
}

// message AppConfig {
//   repeated HostConfig hosts = 1;
// }

// message HostConfig {
//   string host_id = 1;
//   repeated ModuleConfig modules = 2;
// }

// message ModuleConfig {
//   string mod_id = 1;
//   string mod_type = 2;
//   repeated string in_channels = 3;
//   repeated string out_channels = 4;
//   map<string, string> properties = 5;
// }

message ModuleAnnotation
{
  string module_description  = 1;
  repeated string properties = 2;
  repeated string property_descriptions = 3;
  repeated DataPackage channel_definition = 4;
  repeated string channel_description = 5;
}


enum Runtime {
  RUNTIME_UNSPECIFIED = 0;
  RUNTIME_CPP = 1;
  RUNTIME_DART = 2;
  RUNTIME_JAVA = 3;
  RUNTIME_PYTHON = 4;
}

enum LogMessageSeverityLevel
{
  DEBUG_VERBOSE = 0;
  INFO = 1;
  WARNING = 2;
  ERROR = 3;
  FATAL = 4;
}

enum LogMessageEntityType
{
  MIDDLEWARE = 0; // For general messages, i.e., sent from low level middleware functions
  MIDDLEWARE_COMPONENT = 1; // For messages from certain well-defined components within the middleware, e.g., the Router oder RemoteDispatcher
  MODULE = 2; // For log messages directly sent from a certain Module
}

message LogMessage
{
  string log_message = 1;
  LogMessageSeverityLevel severity_level = 2;
  uint64 unix_timestamp_in_ms = 3;
  LogMessageEntityType entity_type = 4;
  string entity_name = 5;
  Runtime runtime = 6; // Runtime from which the message was sent
}


// Determines how log messages shall be transfered to the log sink host
// STORE_AND_UPLOAD is the default option. Log messages will be written to files (one file per hour),
// which will be synchronized with the log sync host once it is available.
// STREAM is an option that can be used if hosts shall livestream their log messages to the log sink host.
// This allows to stream the logs in realtime to the log sink host, however log messages will get lost if there currently is no connection to the log sink host
enum LogSinkTransferMode
{
  STORE_AND_UPLOAD = 0;
  STREAM = 1;
}


// ======= CONFIG =======


// Container for the central CLAID config file. 
// TODO (patrick): change as you see fit, this just a starting point. 
message CLAIDConfig {
  repeated HostConfig hosts = 1; 
  string log_sink_host = 2; // If specified, all CLAID instances will forward their log messages to this host. 
  LogMessageSeverityLevel log_sink_severity_level = 3;  // If log_sink_host is specified, this flag indicates 
                                                        // what category of log messages will be sent to the log sink (only messages with severity level >= this flag will be sent).
  LogSinkTransferMode log_sink_transfer_mode = 4; // Method of transfering log messages to the log_sink_host. Check LogSingTransferMode definition for more details.
  bool designer_mode = 5;                         // If true, other hosts can upload a new config (alongside additional data like model files or python code) to the host.
}

message HostConfig {
  string hostname = 1; 
  string type = 2;
  bool is_server = 3;
  string host_server_address = 4; // If is_server, then this identifies the address of the server. Must be fully specified.
  string connect_to = 5; // If specified, the host will connect to this address. 
                                  // The host can either be a Client connection to a Server, or a Server connecting to another Server.
  repeated ModuleConfig modules = 6;
  string log_folder = 7;  // Path to folder where to store log message to. All log messages with a severity level >= min_log_severity_level will be store there.
                          // Additionally, all log messages with a severity level >= log_sink_severity_level will be stored separately and synced with the log sink host.
                          // The separately stored messages for the log_sink_host will be deleted upon successfull synchronization;
  LogMessageSeverityLevel min_log_severity_level = 8; // Specifies the minimum severity level a log message needs to have in order to be printed and stored to log files.
}

message ModuleConfig
{
  string id = 1; 
  string type = 2;
  map<string, string> input_channels = 3; // Maps input channels to connections, e.g. "InputAudioDataChannel" : "AudioDataConnection"
  map<string, string> output_channels = 4; // Maps output channels to connections, e.g. "AudioDataToProcess" : "AudioDataConnection"
  map<string, string> properties = 5;
}

message DataFile
{
  string relative_path = 1;
  bytes file_data = 2;
}

message ModuleInjectionDescription
{
  repeated string module_names = 1; // Names of modules to inject.
  repeated string module_file = 2; // Name of the file in which the Module can be found. 
  Runtime runtime = 3; // Runtime which shall inject this module.
}

message ConfigUploadPayload
{
  CLAIDConfig config = 1;
  repeated DataFile payload_files = 2;

  // Contains names of Modules which were sent as payload and can be injected by the corresponding Runtimes.
  repeated ModuleInjectionDescription modules_to_inject = 3; 
}
