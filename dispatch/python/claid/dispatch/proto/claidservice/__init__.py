# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: claidservice.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class CtrlType(betterproto.Enum):
    CTRL_UNSPECIFIED = 0
    CTRL_RUNTIME_PING = 1
    CTRL_REMOTE_PING = 2
    CTRL_REMOTE_PING_PONG = 3
    CTRL_CONN_CANCEL = 4
    CTRL_ERROR = 8
    """
    CTRL_MODULE_READY  = 5;  // sent to module when the local middleware is ready
     CTRL_STATUS        = 6;  // Sent from a middleware client up the tree
     CTRL_ACTION        = 7;  // sent to module when the local middleware is ready
    """

    CTRL_CONNECTED_TO_REMOTE_SERVER = 9
    CTRL_DISCONNECTED_FROM_REMOTE_SERVER = 10
    CTRL_UNLOAD_MODULES = 11
    CTRL_UNLOAD_MODULES_DONE = 12
    CTRL_RESTART_RUNTIME = 13
    CTRL_RESTART_RUNTIME_DONE = 14
    CTRL_STOP_RUNTIME = 15
    CTRL_REQUEST_MODULE_ANNOTATIONS = 16
    CTRL_REQUEST_MODULE_ANNOTATIONS_RESPONSE = 17
    CTRL_UPLOAD_CONFIG_AND_DATA = 18
    CTRL_ON_NEW_CONFIG_PAYLOAD_DATA = 19
    CTRL_LOCAL_LOG_MESSAGE = 20
    CTRL_LOG_SINK_LOG_MESSAGE_STREAM = 21
    CTRL_SUBSCRIBE_TO_LOG_SINK_LOG_MESSAGE_STREAM = 22
    CTRL_UNSUBSCRIBE_FROM_LOG_SINK_LOG_MESSAGE_STREAM = 23
    CTRL_PAUSE_MODULE = 24
    CTRL_UNPAUSE_MODULE = 25
    CTRL_ADJUST_POWER_PROFILE = 26
    CTRL_ACTIVATE_NETWORK_CONNECTIONS = 27
    CTRL_DEACTIVATE_NETWORK_CONNECTIONS = 28
    CTRL_REMOTE_FUNCTION_REQUEST = 29
    CTRL_REMOTE_FUNCTION_RESPONSE = 30
    CTRL_DIRECT_SUBSCRIPTION_DATA = 31


class Codec(betterproto.Enum):
    UNSPECIFIED = 0
    BYTES = 1
    FILE = 2
    JSON = 3
    PROTO = 4


class PropertyType(betterproto.Enum):
    DEFAULT = 0
    ENUM = 1
    INT = 2
    PATH = 3


class Runtime(betterproto.Enum):
    UNSPECIFIED = 0
    MIDDLEWARE_CORE = 1
    CPP = 2
    DART = 3
    JAVA = 4
    PYTHON = 5
    SWIFT = 6


class LogMessageSeverityLevel(betterproto.Enum):
    DEBUG_VERBOSE = 0
    INFO = 1
    WARNING = 2
    ERROR = 3
    FATAL = 4


class LogMessageEntityType(betterproto.Enum):
    MIDDLEWARE = 0
    MIDDLEWARE_COMPONENT = 1
    MODULE = 2


class LogSinkTransferMode(betterproto.Enum):
    """
    Determines how log messages shall be transfered to the log sink host
     STORE_AND_UPLOAD is the default option. Log messages will be written to files (one file per hour),
     which will be synchronized with the log sync host once it is available.
     STREAM is an option that can be used if hosts shall livestream their log messages to the log sink host.
     This allows to stream the logs in realtime to the log sink host, however log messages will get lost if there currently is no connection to the log sink host
    """

    STORE_AND_UPLOAD = 0
    STREAM = 1


class PowerProfileType(betterproto.Enum):
    UNRESTRICTED = 0
    POWER_SAVING_MODE = 2


class RemoteFunctionStatus(betterproto.Enum):
    UNDEFINED = 0
    STATUS_OK = 1
    FAILED_FUNCTION_NOT_FOUND_OR_FAILED_TO_EXECUTE = 2
    FAILED_INVALID_NUMBER_OF_PARAMETERS = 3
    FAILED_MISMATCHING_PARAMETERS = 4
    FAILED_MODULE_NOT_FOUND = 5
    REMOTE_FUNCTION_REQUEST_INVALID = 6


class DataSyncPackageType(betterproto.Enum):
    ALL_AVAILABLE_FILES_LIST = 0
    REQUESTED_FILES_LIST = 1
    FILES_DATA = 2
    ACKNOWLEDGED_FILES = 3


@dataclass(eq=False, repr=False)
class DataPackage(betterproto.Message):
    id: str = betterproto.string_field(1)
    channel: str = betterproto.string_field(2)
    source_module: str = betterproto.string_field(3)
    target_module: str = betterproto.string_field(4)
    source_host: str = betterproto.string_field(5)
    target_host: str = betterproto.string_field(6)
    source_user_token: str = betterproto.string_field(7)
    target_user_token: str = betterproto.string_field(8)
    device_id: str = betterproto.string_field(9)
    """
    typically, this will be *, meaning that the package will be forwarded to all users that run the corresponding host.
    """

    trace_points: List["TracePoint"] = betterproto.message_field(10)
    unix_timestamp_ms: int = betterproto.uint64_field(11)
    payload: "Blob" = betterproto.message_field(12)
    control_val: Optional["ControlPackage"] = betterproto.message_field(
        13, optional=True
    )


@dataclass(eq=False, repr=False)
class ControlPackage(betterproto.Message):
    ctrl_type: "CtrlType" = betterproto.enum_field(1)
    runtime: "Runtime" = betterproto.enum_field(2)
    remote_client_info: "RemoteClientInfo" = betterproto.message_field(3)
    status: "AccumulatedStatus" = betterproto.message_field(4)
    error_msg: "ErrorMsg" = betterproto.message_field(5)
    action_request: "ActionRequest" = betterproto.message_field(6)
    module_annotations: Dict[str, "ModuleAnnotation"] = betterproto.map_field(
        7, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    config_upload_payload: "ConfigUploadPayload" = betterproto.message_field(8)
    log_message: "LogMessage" = betterproto.message_field(9)
    power_profile: "PowerProfile" = betterproto.message_field(10)
    remote_function_request: "RemoteFunctionRequest" = betterproto.message_field(11)
    remote_function_return: "RemoteFunctionReturn" = betterproto.message_field(12)
    loose_direct_subscription: "LooseDirectChannelSubscription" = (
        betterproto.message_field(13)
    )


@dataclass(eq=False, repr=False)
class AccumulatedStatus(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ErrorMsg(betterproto.Message):
    message: str = betterproto.string_field(1)
    cancel: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class ActionRequest(betterproto.Message):
    action_params: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """TBD"""


@dataclass(eq=False, repr=False)
class IntVal(betterproto.Message):
    val: int = betterproto.int64_field(1)


@dataclass(eq=False, repr=False)
class DoubleVal(betterproto.Message):
    val: float = betterproto.double_field(1)


@dataclass(eq=False, repr=False)
class NumberArray(betterproto.Message):
    val: List[float] = betterproto.double_field(1)


@dataclass(eq=False, repr=False)
class BoolVal(betterproto.Message):
    val: bool = betterproto.bool_field(1)


@dataclass(eq=False, repr=False)
class StringVal(betterproto.Message):
    val: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class StringArray(betterproto.Message):
    val: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class NumberMap(betterproto.Message):
    val: Dict[str, float] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_DOUBLE
    )


@dataclass(eq=False, repr=False)
class StringMap(betterproto.Message):
    val: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class Blob(betterproto.Message):
    codec: "Codec" = betterproto.enum_field(1)
    payload: bytes = betterproto.bytes_field(2)
    """The byte blob containing the payload data."""

    message_type: str = betterproto.string_field(3)
    """
    type and subtype contains meta information to decode the bytes contained above.
     See this list of common mime types
     https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
    """


@dataclass(eq=False, repr=False)
class TracePoint(betterproto.Message):
    time_stamp: datetime = betterproto.message_field(1)
    node_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ModuleListRequest(betterproto.Message):
    """
    Sent by the client (Runtime) to tell the Middleware which Modules it supports.
     The Middleware will answer with a ModuleListResponse, which contains the Modules
     that the Middleware wants the runtime client to load.
    """

    runtime: "Runtime" = betterproto.enum_field(1)
    supported_module_classes: List[str] = betterproto.string_field(2)
    module_annotations: Dict[str, "ModuleAnnotation"] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class ModuleListResponse(betterproto.Message):
    """List of modules that the runtime client is expected to instantiate."""

    descriptors: List["ModuleListResponseModuleDescriptor"] = betterproto.message_field(
        1
    )
    log_severity_level_for_host: "LogMessageSeverityLevel" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class ModuleListResponseModuleDescriptor(betterproto.Message):
    module_id: str = betterproto.string_field(1)
    module_class: str = betterproto.string_field(2)
    properties: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class InitRuntimeRequest(betterproto.Message):
    """
    Sent by the client after the modules have been instantiated
     to inform the server what channels will be sent.
    """

    runtime: "Runtime" = betterproto.enum_field(1)
    modules: List["InitRuntimeRequestModuleChannels"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class InitRuntimeRequestModuleChannels(betterproto.Message):
    module_id: str = betterproto.string_field(1)
    channel_packets: List["DataPackage"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class RemoteClientInfo(betterproto.Message):
    host: str = betterproto.string_field(1)
    user_token: str = betterproto.string_field(2)
    device_id: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class RemoveModuleRequest(betterproto.Message):
    """Used by CTRL_REMOVE_MODULE to remove a Module at Runtime."""

    module_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class PropertyHint(betterproto.Message):
    property_type: "PropertyType" = betterproto.enum_field(1)
    property_type_enum_values: List[str] = betterproto.string_field(2)
    property_type_int_min: int = betterproto.int64_field(3)
    property_type_int_max: int = betterproto.int64_field(4)


@dataclass(eq=False, repr=False)
class ModuleAnnotation(betterproto.Message):
    module_description: str = betterproto.string_field(1)
    module_category: str = betterproto.string_field(2)
    properties: List[str] = betterproto.string_field(3)
    property_descriptions: List[str] = betterproto.string_field(4)
    property_hints: List["PropertyHint"] = betterproto.message_field(5)
    channel_definition: List["DataPackage"] = betterproto.message_field(6)
    channel_description: List[str] = betterproto.string_field(7)
    is_injectable: bool = betterproto.bool_field(8)
    file_dependencies: List[str] = betterproto.string_field(9)


@dataclass(eq=False, repr=False)
class LogMessage(betterproto.Message):
    log_message: str = betterproto.string_field(1)
    severity_level: "LogMessageSeverityLevel" = betterproto.enum_field(2)
    unix_timestamp_in_ms: int = betterproto.uint64_field(3)
    entity_type: "LogMessageEntityType" = betterproto.enum_field(4)
    entity_name: str = betterproto.string_field(5)
    runtime: "Runtime" = betterproto.enum_field(6)


@dataclass(eq=False, repr=False)
class ClaidConfig(betterproto.Message):
    """Container for the central CLAID config file."""

    hosts: List["HostConfig"] = betterproto.message_field(1)
    log_sink_host: str = betterproto.string_field(2)
    log_sink_severity_level: "LogMessageSeverityLevel" = betterproto.enum_field(3)
    log_sink_transfer_mode: "LogSinkTransferMode" = betterproto.enum_field(4)
    """
    what category of log messages will be sent to the log sink (only messages with severity level >= this flag will be sent).
    """

    log_sink_log_storage_path: str = betterproto.string_field(5)
    milliseconds_deadline_to_load_modules: int = betterproto.int32_field(7)
    """
    bool designer_mode = 5;                         // If true, other hosts can upload a new config (alongside additional data like model files or python code) to the host.
    """


@dataclass(eq=False, repr=False)
class HostConfig(betterproto.Message):
    hostname: str = betterproto.string_field(1)
    type: str = betterproto.string_field(2)
    server_config: "ServerConfig" = betterproto.message_field(3)
    connect_to: "ClientConfig" = betterproto.message_field(4)
    modules: List["ModuleConfig"] = betterproto.message_field(5)
    """
    The host can either be a Client connection to a Server, or a Server connecting to another Server.
    """

    log_folder: str = betterproto.string_field(6)
    min_log_severity_level: "LogMessageSeverityLevel" = betterproto.enum_field(7)
    """
    Additionally, all log messages with a severity level >= log_sink_severity_level will be stored separately and synced with the log sink host.
     The separately stored messages for the log_sink_host will be deleted upon successfull synchronization;
    """


@dataclass(eq=False, repr=False)
class ClientConfig(betterproto.Message):
    host: str = betterproto.string_field(1)
    tls: "ClientTlsConfigServerBasedAuthentication" = betterproto.message_field(
        2, group="security_settings"
    )
    mutual_tls: "ClientTlsConfigMutualAuthentication" = betterproto.message_field(
        3, group="security_settings"
    )


@dataclass(eq=False, repr=False)
class ServerConfig(betterproto.Message):
    host_server_address: str = betterproto.string_field(1)
    tls: "ServerTlsConfigServerBasedAuthentication" = betterproto.message_field(
        2, group="security_settings"
    )
    mutual_tls: "ServerTlsConfigMutualAuthentication" = betterproto.message_field(
        3, group="security_settings"
    )


@dataclass(eq=False, repr=False)
class ClientTlsConfigServerBasedAuthentication(betterproto.Message):
    """
    TLS features two types of authentication:
     - Server-based authentication: The client authenticates the server using its public certificate.
       After the server has been successfully authenticated, client and server exchange a shared secret key,
       which will be used to encrypt the data sent between client and server.
     - Mutual authentication: Both client and server authenticate each other using certificates.
    """

    server_public_certificate: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ClientTlsConfigMutualAuthentication(betterproto.Message):
    client_public_certificate: str = betterproto.string_field(1)
    client_private_key: str = betterproto.string_field(2)
    server_public_certificate: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class ServerTlsConfigServerBasedAuthentication(betterproto.Message):
    server_public_certificate: str = betterproto.string_field(1)
    server_private_key: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ServerTlsConfigMutualAuthentication(betterproto.Message):
    server_public_certificate: str = betterproto.string_field(1)
    server_private_key: str = betterproto.string_field(2)
    client_public_certificate: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class ModuleConfig(betterproto.Message):
    id: str = betterproto.string_field(1)
    type: str = betterproto.string_field(2)
    input_channels: Dict[str, str] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    output_channels: Dict[str, str] = betterproto.map_field(
        4, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    properties: "betterproto_lib_google_protobuf.Struct" = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class DataFile(betterproto.Message):
    relative_path: str = betterproto.string_field(1)
    file_data: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class ModuleInjectionDescription(betterproto.Message):
    module_name: str = betterproto.string_field(1)
    module_file: str = betterproto.string_field(2)
    runtime: "Runtime" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ConfigUploadPayload(betterproto.Message):
    config: "ClaidConfig" = betterproto.message_field(1)
    payload_files: List["DataFile"] = betterproto.message_field(2)
    modules_to_inject: List["ModuleInjectionDescription"] = betterproto.message_field(3)
    """
    Contains names of Modules which were sent as payload and can be injected by the corresponding Runtimes.
    """

    payload_data_path: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class PowerProfile(betterproto.Message):
    """
    Can be used by Modules to support different Power Profiles. For example, the AccelerometerCollector might support sampling at lower frequencies to reduce battery consumption
    """

    power_profile_type: "PowerProfileType" = betterproto.enum_field(1)
    frequency: float = betterproto.double_field(2)
    """
    FREQUENCY AND PERIOD ARE EXCLUSIVE, USE EITHER ONE OR THE OTHER! IT WILL NOT BE VALIDATED WHETHERE period == 1/frequency !!
    """

    period: float = betterproto.double_field(3)
    additional_information: Dict[str, str] = betterproto.map_field(
        4, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class PowerSavingStrategy(betterproto.Message):
    battery_threshold: float = betterproto.float_field(1)
    active_modules: List[str] = betterproto.string_field(2)
    paused_modules: List[str] = betterproto.string_field(3)
    power_profiles: Dict[str, "PowerProfile"] = betterproto.map_field(
        4, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    wake_lock: bool = betterproto.bool_field(5)
    disable_network_connections: bool = betterproto.bool_field(6)
    disable_wifi_and_bluetooth: bool = betterproto.bool_field(7)


@dataclass(eq=False, repr=False)
class PowerSavingStrategyList(betterproto.Message):
    strategies: List["PowerSavingStrategy"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Claidany(betterproto.Message):
    """Used by claid::AnyProtoType"""

    pass


@dataclass(eq=False, repr=False)
class RemoteFunctionIdentifier(betterproto.Message):
    function_name: str = betterproto.string_field(1)
    runtime: "Runtime" = betterproto.enum_field(2, group="function_type")
    module_id: str = betterproto.string_field(3, group="function_type")


@dataclass(eq=False, repr=False)
class RemoteFunctionRequest(betterproto.Message):
    remote_function_identifier: "RemoteFunctionIdentifier" = betterproto.message_field(
        1
    )
    remote_future_identifier: str = betterproto.string_field(2)
    parameter_payloads: List["Blob"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class RemoteFunctionReturn(betterproto.Message):
    execution_status: "RemoteFunctionStatus" = betterproto.enum_field(1)
    remote_function_identifier: "RemoteFunctionIdentifier" = betterproto.message_field(
        2
    )
    remote_future_identifier: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class LooseDirectChannelSubscription(betterproto.Message):
    """
    Can be used for non-Module entities to subscribe directly to the data posted to a channel by a certain Module.
     In regular subscriptions, data is forwarded to all subscribers to a channel, no matter what Module posted the data.
     In loose direct subscriptions, data is forwarded directly to separate non-module subscribers to a channel, but only if the data
     was posted by the Module that the non-module subscriber explicitly subscribed to.
     This typically is used for UI visualizations, allowing UI widgets to subscribe to data posted by a certain Module.
     For example, check out CLAIDModuleView of FlutterCLAID.
    """

    subscriber_runtime: "Runtime" = betterproto.enum_field(1)
    subscriber_entity: str = betterproto.string_field(2)
    subscribed_module: str = betterproto.string_field(3)
    subscribed_channel: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class DataSyncFileDescriptor(betterproto.Message):
    file_size: int = betterproto.uint64_field(1)
    hash: int = betterproto.uint64_field(2)
    relative_file_path: str = betterproto.string_field(3)
    file_data: bytes = betterproto.bytes_field(4)


@dataclass(eq=False, repr=False)
class DataSyncFileDescriptorList(betterproto.Message):
    descriptors: List["DataSyncFileDescriptor"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DataSyncPackage(betterproto.Message):
    package_type: "DataSyncPackageType" = betterproto.enum_field(1)
    file_descriptors: "DataSyncFileDescriptorList" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class RuntimeType(betterproto.Message):
    """Allows to send a runtime via a protobuf message."""

    runtime: "Runtime" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class Schedule(betterproto.Message):
    """
    A Schedule defines specific times for executing functions.
     It can be used to automatically register and trigger functions based on defined intervals, time frames,
     or specific times of day at each runtime.
    """

    periodic: List["SchedulePeriodic"] = betterproto.message_field(1)
    timed: List["ScheduleExactTime"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ScheduleTimeWindow(betterproto.Message):
    start_time_of_day: "ScheduleTimeOfDay" = betterproto.message_field(1)
    stop_time_of_day: "ScheduleTimeOfDay" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ScheduleTimeOfDay(betterproto.Message):
    hour: int = betterproto.int32_field(1)
    minute: int = betterproto.int32_field(2)
    second: int = betterproto.int32_field(3)


@dataclass(eq=False, repr=False)
class SchedulePeriodic(betterproto.Message):
    first_execution_time_of_day: "ScheduleTimeOfDay" = betterproto.message_field(1)
    """
    Optional. If not specified, periodic function will be started immediately.
    """

    only_active_between_time_frame: "ScheduleTimeWindow" = betterproto.message_field(2)
    """Optional. If not specified, periodic function is always active."""

    frequency_hz: float = betterproto.double_field(3, group="interval")
    frequency_k_hz: float = betterproto.double_field(4, group="interval")
    frequency_m_hz: float = betterproto.double_field(5, group="interval")
    period_milliseconds: float = betterproto.double_field(6, group="interval")
    period_seconds: float = betterproto.double_field(7, group="interval")
    period_minutes: float = betterproto.double_field(8, group="interval")
    period_hours: float = betterproto.double_field(9, group="interval")
    period_days: float = betterproto.double_field(10, group="interval")


@dataclass(eq=False, repr=False)
class ScheduleExactTime(betterproto.Message):
    time_of_day: "ScheduleTimeOfDay" = betterproto.message_field(1)
    repeat_every_n_days: float = betterproto.double_field(2)


class ClaidServiceStub(betterproto.ServiceStub):
    async def send_receive_packages(
        self,
        data_package_iterator: Union[AsyncIterable[DataPackage], Iterable[DataPackage]],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[DataPackage]:
        async for response in self._stream_stream(
            "/claidservice.ClaidService/SendReceivePackages",
            data_package_iterator,
            DataPackage,
            DataPackage,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_module_list(
        self,
        module_list_request: "ModuleListRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ModuleListResponse":
        return await self._unary_unary(
            "/claidservice.ClaidService/GetModuleList",
            module_list_request,
            ModuleListResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def init_runtime(
        self,
        init_runtime_request: "InitRuntimeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        return await self._unary_unary(
            "/claidservice.ClaidService/InitRuntime",
            init_runtime_request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ClaidRemoteServiceStub(betterproto.ServiceStub):
    async def send_receive_packages(
        self,
        data_package_iterator: Union[AsyncIterable[DataPackage], Iterable[DataPackage]],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[DataPackage]:
        async for response in self._stream_stream(
            "/claidservice.ClaidRemoteService/SendReceivePackages",
            data_package_iterator,
            DataPackage,
            DataPackage,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class ClaidServiceBase(ServiceBase):

    async def send_receive_packages(
        self, data_package_iterator: AsyncIterator[DataPackage]
    ) -> AsyncIterator[DataPackage]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DataPackage()

    async def get_module_list(
        self, module_list_request: "ModuleListRequest"
    ) -> "ModuleListResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def init_runtime(
        self, init_runtime_request: "InitRuntimeRequest"
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_send_receive_packages(
        self, stream: "grpclib.server.Stream[DataPackage, DataPackage]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.send_receive_packages,
            stream,
            request,
        )

    async def __rpc_get_module_list(
        self, stream: "grpclib.server.Stream[ModuleListRequest, ModuleListResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_module_list(request)
        await stream.send_message(response)

    async def __rpc_init_runtime(
        self,
        stream: "grpclib.server.Stream[InitRuntimeRequest, betterproto_lib_google_protobuf.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.init_runtime(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/claidservice.ClaidService/SendReceivePackages": grpclib.const.Handler(
                self.__rpc_send_receive_packages,
                grpclib.const.Cardinality.STREAM_STREAM,
                DataPackage,
                DataPackage,
            ),
            "/claidservice.ClaidService/GetModuleList": grpclib.const.Handler(
                self.__rpc_get_module_list,
                grpclib.const.Cardinality.UNARY_UNARY,
                ModuleListRequest,
                ModuleListResponse,
            ),
            "/claidservice.ClaidService/InitRuntime": grpclib.const.Handler(
                self.__rpc_init_runtime,
                grpclib.const.Cardinality.UNARY_UNARY,
                InitRuntimeRequest,
                betterproto_lib_google_protobuf.Empty,
            ),
        }


class ClaidRemoteServiceBase(ServiceBase):

    async def send_receive_packages(
        self, data_package_iterator: AsyncIterator[DataPackage]
    ) -> AsyncIterator[DataPackage]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DataPackage()

    async def __rpc_send_receive_packages(
        self, stream: "grpclib.server.Stream[DataPackage, DataPackage]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.send_receive_packages,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/claidservice.ClaidRemoteService/SendReceivePackages": grpclib.const.Handler(
                self.__rpc_send_receive_packages,
                grpclib.const.Cardinality.STREAM_STREAM,
                DataPackage,
                DataPackage,
            ),
        }
